name: Sync Main to Develop

on:
  push:
    branches:
      - main
  workflow_dispatch:

concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write

jobs:
  sync-main-to-develop:
    runs-on: ubuntu-latest
    steps:
      - name: Ensure develop catches up with main
        uses: actions/github-script@v8
        with:
          github-token: ${{ secrets.RELEASE_PLZ_TOKEN || github.token }}
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const conflictMarker = '<!-- sync-main-to-develop-conflict -->';
            const syncLabels = ['sync-main-develop', 'automerge'];
            const summaryPath = process.env.GITHUB_STEP_SUMMARY;
            const summaryLines = ['## Sync Main to Develop', ''];

            const pushSummary = (line = '') => {
              summaryLines.push(line);
            };

            const flushSummary = () => {
              if (!summaryPath) {
                return;
              }
              fs.appendFileSync(summaryPath, `${summaryLines.join('\n')}\n`, 'utf8');
            };

            core.info(`sync trigger actor: ${context.actor}`);
            pushSummary(`- Trigger actor: ${context.actor}`);

            const compare = await github.rest.repos.compareCommitsWithBasehead({
              owner,
              repo,
              basehead: 'develop...main',
            });

            if (compare.data.ahead_by === 0) {
              core.info('develop already contains main; no sync PR required.');
              pushSummary('- Result: develop already contains main (no sync PR needed).');
              flushSummary();
              return;
            }

            const openPulls = await github.rest.pulls.list({
              owner,
              repo,
              state: 'open',
              base: 'develop',
              head: `${owner}:main`,
              per_page: 100,
            });

            if (openPulls.data.length > 0) {
              core.info(`Sync PR already open: #${openPulls.data[0].number}`);
            }

            let syncPull = openPulls.data[0];

            if (!syncPull) {
              try {
                const pull = await github.rest.pulls.create({
                  owner,
                  repo,
                  title: 'chore: sync main into develop',
                  head: 'main',
                  base: 'develop',
                  body: [
                    'Automated sync PR to keep `develop` aligned with commits that land on `main`.',
                    '',
                    '- Trigger: push on `main`',
                    '- Purpose: avoid manual back-merge and branch drift',
                  ].join('\n'),
                });

                syncPull = pull.data;
                core.info(`Created sync PR #${syncPull.number}: ${syncPull.html_url}`);
                pushSummary(`- Sync PR created: #${syncPull.number}`);
              } catch (error) {
                if (error && error.status === 403) {
                  core.setFailed('Insufficient token permissions to create sync PR. Ensure contents/pull-requests write permissions and token policy allow workflow PR creation.');
                  pushSummary('- Result: failed to create sync PR due to insufficient permissions.');
                  flushSummary();
                  return;
                }
                throw error;
              }
            }

            if (syncPull) {
              pushSummary(`- Sync PR: #${syncPull.number} (${syncPull.html_url})`);
            }

            for (const label of syncLabels) {
              try {
                await github.rest.issues.getLabel({ owner, repo, name: label });
              } catch (error) {
                if (error && error.status === 404) {
                  await github.rest.issues.createLabel({
                    owner,
                    repo,
                    name: label,
                    color: '0e8a16',
                    description: 'Automated sync workflow label',
                  });
                } else {
                  throw error;
                }
              }
            }

            await github.rest.issues.addLabels({
              owner,
              repo,
              issue_number: syncPull.number,
              labels: syncLabels,
            });
            pushSummary(`- Labels ensured: ${syncLabels.join(', ')}`);

            let detail = null;
            for (let attempt = 0; attempt < 6; attempt += 1) {
              const response = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: syncPull.number,
              });
              detail = response.data;
              if (detail.mergeable !== null) {
                break;
              }
              await new Promise((resolve) => setTimeout(resolve, 3000));
            }

            if (!detail) {
              core.setFailed(`Unable to inspect mergeability for sync PR #${syncPull.number}.`);
              pushSummary(`- Result: failed to inspect mergeability for #${syncPull.number}.`);
              flushSummary();
              return;
            }

            if (detail.mergeable === false || detail.mergeable_state === 'dirty') {
              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: syncPull.number,
                per_page: 100,
              });

              const alreadyCommented = comments.data.some((comment) =>
                (comment.body || '').includes(conflictMarker)
              );

              if (!alreadyCommented) {
                try {
                  await github.rest.issues.createComment({
                    owner,
                    repo,
                    issue_number: syncPull.number,
                    body: [
                      conflictMarker,
                      '⚠️ Automatic sync PR has merge conflicts.',
                      '',
                      'Manual conflict resolution is required to keep `develop` aligned with `main`.',
                    ].join('\n'),
                  });
                } catch (error) {
                  if (error && error.status === 403) {
                    core.warning('Cannot post conflict comment due to token permissions.');
                  } else {
                    throw error;
                  }
                }
              }

              core.setFailed(
                `Sync PR #${syncPull.number} is not mergeable (state=${detail.mergeable_state}). Resolve conflicts manually.`
              );
              pushSummary(`- Result: PR #${syncPull.number} has conflicts (${detail.mergeable_state}). Manual resolution required.`);
              flushSummary();
              return;
            }

            core.info(`Sync PR #${syncPull.number} is mergeable (state=${detail.mergeable_state}).`);

            if (detail.auto_merge !== null) {
              core.info(`Auto-merge already enabled for sync PR #${syncPull.number}.`);
              pushSummary(`- Auto-merge already enabled for #${syncPull.number}.`);
              flushSummary();
              return;
            }

            // Only wait while GitHub has not computed mergeability yet.
            // If state is unstable, still attempt to queue auto-merge immediately.
            const unstableStates = new Set(['unknown']);
            let stableDetail = detail;
            for (let attempt = 0; attempt < 90; attempt += 1) {
              const state = String(stableDetail.mergeable_state || '').toLowerCase();
              if (!unstableStates.has(state)) {
                break;
              }

              core.info(`Sync PR #${syncPull.number} is currently ${state}; waiting before enabling auto-merge (attempt ${attempt + 1}/90).`);
              await new Promise((resolve) => setTimeout(resolve, 5000));

              const refreshed = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: syncPull.number,
              });
              stableDetail = refreshed.data;
            }

            if (stableDetail.auto_merge !== null) {
              core.info(`Auto-merge already enabled for sync PR #${syncPull.number}.`);
              pushSummary(`- Auto-merge already enabled for #${syncPull.number}.`);
              flushSummary();
              return;
            }

            const finalState = String(stableDetail.mergeable_state || '').toLowerCase();
            if (unstableStates.has(finalState)) {
              core.warning(`Sync PR #${syncPull.number} remained ${finalState}; skipping auto-merge enable for now.`);
              pushSummary(`- Result: PR #${syncPull.number} stayed ${finalState}; auto-merge not enabled in this run.`);
              flushSummary();
              return;
            }

            try {
              const mutation = `
                mutation EnableAutoMerge($pullRequestId: ID!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: MERGE
                  }) {
                    pullRequest {
                      number
                    }
                  }
                }
              `;

              await github.graphql(mutation, {
                pullRequestId: stableDetail.node_id,
              });

              core.info(`Auto-merge enabled for sync PR #${syncPull.number}. GitHub will merge when checks pass.`);
              pushSummary(`- Auto-merge enabled for #${syncPull.number}.`);
              flushSummary();
            } catch (error) {
              const message = (error && error.message) ? String(error.message) : String(error);

              if (/unstable status/i.test(message) || /reviews are required/i.test(message)) {
                core.info(`Auto-merge request accepted (queued state): ${message}`);
                pushSummary(`- Auto-merge request queued for #${syncPull.number}.`);
                flushSummary();
                return;
              }

              if (error && (error.status === 403 || /Resource not accessible by integration/i.test(message))) {
                core.setFailed('Insufficient permissions to enable auto-merge for sync PR. Ensure token has pull request write scope and repository allows auto-merge.');
                pushSummary(`- Result: permission error while enabling auto-merge for #${syncPull.number}.`);
                flushSummary();
                return;
              }

              if (/auto-merge is disabled/i.test(message)) {
                core.setFailed('Repository auto-merge is disabled. Enable repository setting: Allow auto-merge.');
                pushSummary('- Result: repository auto-merge is disabled.');
                flushSummary();
                return;
              }

              throw error;
            }
